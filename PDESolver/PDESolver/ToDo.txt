# TODO #

adi matrisi yaz
Cyclic reduction yaz / O(n) tri algoları karşılaştır
Introduction + solving pdes paragrafları toparla
Figürler ece

Sorular
stability/consistency analysis??
appendixe code bits lazim mi hangileri?
why uniform grid olunca daha iyi oluyor araştır?? Formula to determine optimal grid sizing?
openmp collapse only in intel compiler how to go ahead

Toparlama
bibtex ref düzelt
grammarlyden geçir
kodlarin basina author date description ekle
Timinge gore heatmap hazirla
Root mean squared relative error testing

# Further Studies #
More type of options BSPde bdegistir callputflag duffy c++ 677 
Generalize ADI (multi assset BS)
Rannacher trick (168 foreign exchange pricing rannacher ve stencil)
Greeks
Burst cloud functions
Rannacher trick

cash-flushes: When you ask for a piece of data from memory, as getting stuff from memory is slow but can be vectorised, a whole load of consecutive values are copied from RAM into the cache. This means that if you are doing a matrix operation that uses the first column of values, then the second etc. It is much better to store these values in memory as column 1, then column 2 etc. If you save it as Row1, Row 2 etc, then every time you access a new element the CPU will have to flush the cache: delete all its values and again load a set of consecutive values from memory. The differences can be very big. So you should have a look at how you implement the ADI method and decide whether the way the calculations are done, it is much better to have the arrays stored by a list of columns or of rows. And it could be (but I have not checked this, so this is just an optimistic dream) that ArrayOld and ArrayNew need different storage. If this were to be so then this would be a quite interesting discovery.